{"id":"MDEwOkRpc2N1c3Npb24zMzk2MjAx","title":"JavaScript 的工作原理：事件循环和异步编程","bodyHTML":"<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" rel=\"nofollow\">[MDN] 并发模型与事件循环</a></li>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" rel=\"nofollow\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5\" rel=\"nofollow\">How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await</a></li>\n</ul>","category":{"name":"FE"},"labels":{"edges":[{"node":{"id":"MDU6TGFiZWwzMDI2NDEyNzMy","name":"interview"}},{"node":{"id":"MDU6TGFiZWwzMDU4MTcxMjgz","name":"node"}}]},"reactions":{"totalCount":0,"edges":[]},"comments":{"edges":[{"node":{"id":"MDE3OkRpc2N1c3Npb25Db21tZW50ODI1Mjk3","bodyHTML":"<h2>Node.js</h2>\n<h3>什么是事件循环 (What is the Event Loop)?</h3>\n<p>事件循环是 Node.js 处理非阻塞 I/O 操作的机制——尽管 JavaScript 是单线程处理的——当有可能的时候，它们会把操作转移到系统内核中去。<br>\n目前大多数内核都是多线程的，它们可在后台处理多种操作。当其中的一个操作完成的时候，内核通知 Node.js 将适合的回调函数添加到<code>轮询</code>队列中等待时机执行。</p>\n<h3>事件循环机制解析 (Event Loop Explained)</h3>\n<p>当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本（或丢入到 <a href=\"https://nodejs.org/api/repl.html#repl_repl\" rel=\"nofollow\">REPL</a>），它可能会调用一些异步的 API、调度定时器，或者调用 process.nextTick()，然后开始处理事件循环。</p>\n<div class=\"highlight highlight-source-shell position-relative\" data-snippet-clipboard-copy-content=\"# 事件循环操作顺序的简化概览\n\n# 1. 每个框为事件循环机制的一个阶段\n# 2. 每个阶段都有一个 FIFO 队列来执行回调\n\n   ┌───────────────────────────┐\n┌─&gt;│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │&lt;─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> 事件循环操作顺序的简化概览</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> 1. 每个框为事件循环机制的一个阶段</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> 2. 每个阶段都有一个 FIFO 队列来执行回调</span>\n\n   ┌───────────────────────────┐\n┌─<span class=\"pl-k\">&gt;</span>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<span class=\"pl-k\">&lt;</span>─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘</pre></div>\n<ul>\n<li><strong><code>timers</code></strong>: 定时器 - 本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li>\n<li><strong><code>pending callbacks</code></strong>: 待定回调 - 执行延迟到下一个循环迭代的 I/O 回调。</li>\n<li><strong><code>idle, prepare</code></strong>: 仅系统内部使用。</li>\n<li><strong><code>poll</code></strong>: 轮询 - 检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 <code>setImmediate()</code> 调度的之外），其余情况 node 将在适当的时候在此阻塞。此阶段有两个重要功能：\n<ol>\n<li>计算应该阻塞和轮询 I/O 的时间。</li>\n<li>然后，处理 <code>轮询</code> 队列里的事件。</li>\n</ol>\n</li>\n<li><strong><code>check</code></strong>: 检测 - <code>setImmediate()</code> 回调函数在这里执行。</li>\n<li><strong><code>close callbacks</code></strong>: 关闭的回调函数 - 一些关闭的回调函数，如：<code>socket.on('close', ...)</code>。</li>\n</ul>\n<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。</p>","author":{"login":"lencx","avatarUrl":"https://avatars.githubusercontent.com/u/16164244?u=77d1d01930d8e36105a49a6c474abf70eeee74b1&v=4","url":"https://github.com/lencx"},"replies":{"edges":[]}}}]}}